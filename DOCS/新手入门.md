# Unity 框架新手入门指南

## 目录

- [写在前面](#写在前面)
- [第一个程序：让游戏跑起来](#第一个程序让游戏跑起来)
- [第1课：什么是单例模式](#第1课什么是单例模式)
- [第2课：如何加载图片和模型](#第2课如何加载图片和模型)
- [第3课：如何让物体飞来飞去但不卡顿](#第3课如何让物体飞来飞去但不卡顿)
- [第4课：如何让两个脚本说话](#第4课如何让两个脚本说话)
- [第5课：如何实现倒计时](#第5课如何实现倒计时)
- [第6课：如何制作界面UI](#第6课如何制作界面ui)
- [第7课：如何播放音效和音乐](#第7课如何播放音效和音乐)
- [第8课：如何处理玩家输入](#第8课如何处理玩家输入)
- [第9课：如何切换场景](#第9课如何切换场景)
- [第10课：常用工具函数](#第10课常用工具函数)
- [常见问题急救箱](#常见问题急救箱)
- [我的第一个游戏完整示例](#我的第一个游戏完整示例)

---

## 写在前面

你好！欢迎使用这个Unity框架。

如果你是Unity新手，可能会觉得"框架"这个词很高大上，但实际上框架就是一个**工具箱**。这个工具箱里装了很多现成的小工具，你只需要知道每个工具怎么用，就能快速做出游戏来。

这个文档会手把手教你，从最基础的概念开始，用最简单的话解释每个模块是干什么的，怎么用。我会给你大量的示例代码，你只需要复制粘贴，改改参数就能用。

不用担心学不会，我们开始吧！

---

## 第一个程序：让游戏跑起来

### 场景搭建

首先，你需要做一个最基础的场景设置，让框架能够工作起来。

**步骤1：创建启动物体**

在Unity编辑器中：
1. 右键点击Hierarchy面板空白处
2. 选择 "Create Empty"（创建空物体）
3. 将其命名为 "GameStart"

**步骤2：创建启动脚本**

在Project面板中：
1. 右键点击空白处
2. 选择 "Create > C# Script"
3. 将其命名为 "GameStart"
4. 双击打开，粘贴以下代码：

```csharp
using UnityEngine;

public class GameStart : MonoBehaviour
{
    private void Awake()
    {
        // 这段代码会在游戏开始时自动执行
        Debug.Log("游戏框架启动成功！");
        Debug.Log("现在你可以使用框架的所有功能了。");
    }
}
```

**步骤3：挂载脚本**

将 "GameStart" 脚本拖拽到 "GameStart" 物体上。

**步骤4：运行测试**

点击Unity编辑器上方的播放按钮（Play），如果Console面板显示"游戏框架启动成功！"，说明框架已经可以正常工作了。

### 重要概念：Awake和Start

在上面的代码中，我们用了 `Awake()` 这个函数。这是Unity的一个特殊函数，它会在物体被创建时**立即执行**，而且只执行一次。

类似的还有 `Start()` 函数，它在 `Awake()` 之后、`Update()` 之前执行。

```csharp
public class Example : MonoBehaviour
{
    private void Awake()
    {
        // 最先执行，早于Start
        Debug.Log("Awake 被调用了");
    }
    
    private void Start()
    {
        // 在Awake之后，每个体只执行一次
        Debug.Log("Start 被调用了");
    }
    
    private void Update()
    {
        // 每帧都执行，大约每秒60次
        // 这里的代码会一直运行
    }
}
```

### 新手常见错误

**错误1：忘记挂载脚本**
- 脚本写好了，但忘记拖到物体上
- 解决：检查物体是否挂载了脚本

**错误2：脚本名和类名不一致**
- 脚本文件名是 "GameStart"，但类名写成 "game_start"
- 解决：确保文件名和类名完全一致

---

## 第1课：什么是单例模式

### 什么是单例？

"单例"听起来很专业，但其实很好理解。

想象一下：你的游戏里有一个**音乐管理器**，负责播放背景音乐和音效。这个音乐管理器只需要一个就够了——你不会想同时有两个音乐管理器一起工作吧？那音乐就会乱套。

单例模式就是保证**某个类在整个游戏中只有唯一一个实例**，而且你可以随时随地访问它。

### 如何使用单例

这个框架已经写好了单例的基础代码，你只需要按照规定的方式写你的类就行。

**方式1：普通的单例（用于不需要挂载到物体的类）**

```csharp
// 这种单例不需要挂在Unity物体上，完全在内存中运行
public class MyManager : BaseManager<MyManager>
{
    // 把构造函数设为私有，防止外部创建多个实例
    private MyManager() { }
    
    // 你的功能代码
    public void DoSomething()
    {
        Debug.Log("单例工作正常！");
    }
    
    public int Calculate(int a, int b)
    {
        return a + b;
    }
}

// 使用方法：直接通过 Instance 访问
public class Test : MonoBehaviour
{
    private void Start()
    {
        // 调用单例的方法
        MyManager.Instance.DoSomething();
        int result = MyManager.Instance.Calculate(10, 20);
        Debug.Log($"计算结果：{result}");
    }
}
```

**方式2：自动单例（推荐，用于需要挂载到物体的类）**

```csharp
// 这种单例会自动创建物体并挂载脚本，你不用手动操作
public class GameController : SingletonAutoMono<GameController>
{
    // 这里可以直接写游戏逻辑
    public int score = 0;
    
    public void AddScore(int value)
    {
        score += value;
        Debug.Log($"得分：{score}");
    }
}

// 使用方法：同样直接通过 Instance 访问
public class Test : MonoBehaviour
{
    private void Start()
    {
        // 自动创建GameController物体
        GameController.Instance.AddScore(100);
        Debug.Log($"当前分数：{GameController.Instance.score}");
    }
}
```

### 什么时候用哪种单例？

| 场景 | 使用方式 |
|------|----------|
| 只管理数据，不操作物体 | `BaseManager<T>` |
| 需要在Update里运行 | `SingletonAutoMono<T>` |
| 需要在场景里手动控制 | `SingletonMono<T>` |

### 新手常见问题

**问题：Instance是null怎么办？**

```csharp
// 错误写法：可能在单例创建之前就访问了
void Start()
{
    // 如果在Awake之前访问，可能会出问题
    MyManager.Instance.DoSomething();
}

// 正确写法：使用前判断
void Start()
{
    if (MyManager.Instance != null)
    {
        MyManager.Instance.DoSomething();
    }
}
```

### 实战：创建一个分数管理器

```csharp
// 文件名：ScoreManager.cs
using UnityEngine;

public class ScoreManager : BaseManager<ScoreManager>
{
    private int score = 0;
    private int highScore = 0;
    
    private ScoreManager() 
    {
        // 读取最高分
        highScore = PlayerPrefs.GetInt("HighScore", 0);
    }
    
    // 加分
    public void AddScore(int value)
    {
        score += value;
        Debug.Log($"得分：{score}");
        
        // 检查是否打破最高分
        if (score > highScore)
        {
            highScore = score;
            PlayerPrefs.SetInt("HighScore", highScore);
            PlayerPrefs.Save();
            Debug.Log($"新纪录！最高分：{highScore}");
        }
    }
    
    // 重置分数
    public void ResetScore()
    {
        score = 0;
        Debug.Log("分数已重置");
    }
    
    // 获取当前分数
    public int GetScore()
    {
        return score;
    }
    
    // 获取最高分
    public int GetHighScore()
    {
        return highScore;
    }
}

// 使用方法
public class Player : MonoBehaviour
{
    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Coin"))
        {
            // 收集金币，加10分
            ScoreManager.Instance.AddScore(10);
            Destroy(other.gameObject);
        }
    }
}
```

---

## 第2课：如何加载图片和模型

### 加载资源基础

在游戏开发中，你经常需要加载图片（Sprite）、模型（GameObject）、音效（AudioClip）等资源。这个框架提供了几种加载方式。

### 方法1：使用ResMgr加载Resources文件夹里的资源

**第一步：放资源**

把要加载的资源放进 `Assets/Resources` 文件夹里。

```
Assets/
└── Resources/
    ├── Prefabs/
    │   ├── Player.prefab
    │   └── Enemy.prefab
    ├── Images/
    │   ├── Background.png
    │   └── Icon.png
    └── Audio/
        ├── BGM.mp3
        └── Jump.wav
```

**第二步：写代码加载**

```csharp
// 同步加载（适合小资源）
public class ResourceLoader : MonoBehaviour
{
    private void Start()
    {
        // 加载预制体
        GameObject playerPrefab = ResMgr.Instance.Load<GameObject>("Prefabs/Player");
        
        // 加载图片
        Sprite background = ResMgr.Instance.Load<Sprite>("Images/Background");
        
        // 加载音效
        AudioClip jumpSound = ResMgr.Instance.Load<AudioClip>("Audio/Jump");
        
        // 加载后使用
        Instantiate(playerPrefab);
    }
}

// 异步加载（适合大资源，会弹出加载界面）
public class AsyncLoader : MonoBehaviour
{
    public Slider loadingBar;  // 拖一个Slider用来显示进度
    
    private void Start()
    {
        // 异步加载，预制体
        ResMgr.Instance.LoadAsync<GameObject>("Prefabs/Enemy", (prefab) =>
        {
            // 这个回调在加载完成后执行
            Instantiate(prefab);
            Debug.Log("敌人预制体加载完成！");
        });
        
        // 异步加载图片
        ResMgr.Instance.LoadAsync<Sprite>("Images/Icon", (sprite) =>
        {
            // 图片加载完成的回调
            GetComponent<Image>().sprite = sprite;
        });
    }
}
```

### 方法2：使用ABMgr加载AssetBundle

AssetBundle是一种更专业的资源管理方式，适合：
- 大型游戏
- 需要热更新的游戏
- 需要DLC的游戏

```csharp
// 异步加载AB包中的资源
public class ABLoader : MonoBehaviour
{
    private void Start()
    {
        // 加载名为"levels"的AB包中的"boss"预制体
        ABMgr.Instance.LoadResAsync<GameObject>("levels", "boss", (bossPrefab) =>
        {
            Instantiate(bossPrefab);
            Debug.Log("BOSS加载完成！");
        });
        
        // 加载材质
        ABMgr.Instance.LoadResAsync<Material>("materials", "boss_mat", (mat) =>
        {
            GetComponent<Renderer>().material = mat;
        });
    }
}
```

### 方法3：开发时用EditorResMgr

在编辑器里开发时，可以用EditorResMgr直接加载资源，方便调试。

```csharp
// 开发时自动加载编辑器里的资源
public class EditorLoader : MonoBehaviour
{
    private void Start()
    {
        // 设置为true时，会从Editor下的资源加载
        ABResMgr.Instance.isDebug = true;
        
        // 加载资源（开发时走EditorResMgr，发布后走ABMgr）
        ABResMgr.Instance.LoadResAsync<GameObject>("ui", "main_panel", (panel) =>
        {
            Instantiate(panel);
        });
    }
}
```

### 加载网络图片

游戏里可能需要从服务器下载图片，比如玩家头像：

```csharp
public class NetworkLoader : MonoBehaviour
{
    private Image playerImage;
    
    private void Start()
    {
        playerImage = GetComponent<Image>();
    }
    
    public void LoadPlayerAvatar(string url)
    {
        // 从网络加载图片
        UWQResMgr.Instance.LoadRes<Texture>(url, 
            (texture) =>
            {
                // 下载成功
                playerImage.sprite = Sprite.Create(
                    (Texture2D)texture,
                    new Rect(0, 0, texture.width, texture.height),
                    new Vector2(0.5f, 0.5f)
                );
            },
            () =>
            {
                // 下载失败
                Debug.LogError("图片下载失败！");
            }
        );
    }
}
```

### 资源卸载

资源加载后会占用内存，不用的时候要记得卸载：

```csharp
public class ResourceManager : MonoBehaviour
{
    private void UnloadUnusedResources()
    {
        // 卸载所有未使用的资源
        ResMgr.Instance.UnloadUnusedAssets(() =>
        {
            Debug.Log("无用资源已卸载，内存释放！");
        });
    }
    
    // 卸载指定资源
    private void UnloadSpecificResource()
    {
        // refCount降到0时才会真正卸载
        ResMgr.Instance.UnloadAsset<GameObject>("Prefabs/Player");
    }
}
```

### 新手常见问题

**问题1：资源加载返回null**

```csharp
// 检查1：资源路径是否正确
// 错误：大小写不对
GameObject prefab = ResMgr.Instance.Load<GameObject>("prefabs/player");

// 正确：大小写和路径都要对
GameObject prefab = ResMgr.Instance.Load<GameObject>("Prefabs/Player");

// 检查2：资源是否在Resources文件夹
// 确保路径是 Assets/Resources/xxx
```

**问题2：异步加载不执行回调**

```csharp
// 检查：回调是否为null
// 确保回调函数存在
ResMgr.Instance.LoadAsync<GameObject>("Prefabs/Player", (prefab) =>
{
    // 这里写加载完成后的代码
    if (prefab != null)
    {
        Instantiate(prefab);
    }
});
```

---

## 第3课：如何让物体飞来飞去但不卡顿

### 问题引出

在游戏里，你可能会创建很多子弹、怪物、特效。如果每创建一个都用 `Instantiate()`，用完再用 `Destroy()` 删除，会产生两个问题：

1. **内存碎片**：频繁创建删除会导致内存碎片
2. **卡顿**：垃圾回收（GC）会突然运行，造成卡顿

### 解决方案：对象池

对象池的核心思想是：**预先创建一定数量的对象，用的时候拿出来，不用的时候放回去，而不是销毁。**

### 对象池使用

**第一步：准备预制体**

1. 创建子弹预制体
2. 在根物体上挂载 `PoolObj` 脚本
3. 设置 `maxNum`（最大数量）

```csharp
// 文件名：Bullet.cs
// 挂载在子弹预制体上
using UnityEngine;

public class Bullet : MonoBehaviour, IPoolObject
{
    public float speed = 20f;
    public int damage = 10;
    
    private Rigidbody rb;
    
    private void Awake()
    {
        rb = GetComponent<Rigidbody>();
    }
    
    // 发射子弹
    public void Fire(Vector3 position, Vector3 direction)
    {
        transform.position = position;
        transform.rotation = Quaternion.LookRotation(direction);
        rb.velocity = direction * speed;
        gameObject.SetActive(true);
    }
    
    // 对象回收到池时调用，用于重置状态
    public void ResetInfo()
    {
        // 停止移动
        rb.velocity = Vector3.zero;
        // 隐藏物体
        gameObject.SetActive(false);
    }
}
```

**第二步：使用对象池**

```csharp
// 文件名：BulletSystem.cs
using UnityEngine;

public class BulletSystem : MonoBehaviour
{
    public Transform firePoint;  // 拖入发射点物体
    
    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            Fire();
        }
    }
    
    private void Fire()
    {
        // 从对象池获取子弹
        Bullet bullet = PoolMgr.Instance.GetObj<Bullet>("Bullet");
        
        // 设置子弹位置和方向
        bullet.Fire(firePoint.position, firePoint.forward);
    }
    
    // 子弹碰撞后回收
    public void回收Bullet(Bullet bullet)
    {
        // 延迟回收，让子弹飞一会儿
        Invoke(() => PoolMgr.Instance.PushObj(bullet), 2f);
    }
}
```

### 对象池完整示例

```csharp
// 完整的敌人生成系统
public class EnemySpawner : MonoBehaviour
{
    public Transform[] spawnPoints;  // 多个出生点
    private float spawnTimer = 0;
    private float spawnInterval = 2f;
    
    private void Update()
    {
        if (GameManager.IsPaused) return;
        
        spawnTimer += Time.deltaTime;
        if (spawnTimer >= spawnInterval)
        {
            spawnTimer = 0;
            SpawnEnemy();
        }
    }
    
    private void SpawnEnemy()
    {
        // 从对象池获取敌人
        Enemy enemy = PoolMgr.Instance.GetObj<Enemy>("Enemy");
        
        // 随机选择出生点
        Transform spawnPoint = spawnPoints[Random.Range(0, spawnPoints.Length)];
        
        // 初始化敌人
        enemy.Init(spawnPoint.position, GameManager.CurrentLevel);
        
        // 敌人死亡时回收
        enemy.onDeath += () => PoolMgr.Instance.PushObj(enemy);
    }
    
    // 预热对象池（游戏开始时创建一些）
    public void Prewarm()
    {
        for (int i = 0; i < 10; i++)
        {
            var enemy = PoolMgr.Instance.GetObj<Enemy>("Enemy");
            PoolMgr.Instance.PushObj(enemy);
        }
        Debug.Log("对象池预热完成！");
    }
}

// 敌人回收示例
public class Enemy : MonoBehaviour, IPoolObject
{
    public int hp = 100;
    private bool isDead = false;
    
    public System.Action onDeath;  // 死亡回调
    
    public void Init(Vector3 position, int level)
    {
        transform.position = position;
        hp = 100 + level * 20;
        isDead = false;
        gameObject.SetActive(true);
    }
    
    public void TakeDamage(int damage)
    {
        if (isDead) return;
        
        hp -= damage;
        if (hp <= 0)
        {
            Die();
        }
    }
    
    private void Die()
    {
        isDead = true;
        onDeath?.Invoke();  // 触发死亡回调，回收敌人
        
        // 也可以直接回收
        // PoolMgr.Instance.PushObj(this);
    }
    
    public void ResetInfo()
    {
        hp = 0;
        isDead = true;
        onDeath = null;
        gameObject.SetActive(false);
    }
}
```

### 新手常见问题

**问题1：对象池不工作**

```csharp
// 检查1：预制体名称是否正确
// PoolMgr.Instance.GetObj("Bullet") 中的 "Bullet" 要和预制体文件名一致

// 检查2：是否挂载了PoolObj脚本
// 在预制体根物体上挂载 PoolObj 脚本

// 检查3：IPoolObject接口是否实现
public class Bullet : MonoBehaviour, IPoolObject
{
    public void ResetInfo() { }  // 必须实现这个方法
}
```

**问题2：对象池数量不够**

```csharp
// 在PoolObj脚本上设置maxNum
// 或者动态扩容
public void ExpandPool(string poolName, int additionalCount)
{
    for (int i = 0; i < additionalCount; i++)
    {
        var obj = PoolMgr.Instance.GetObj(poolName);
        PoolMgr.Instance.PushObj(obj);
    }
}
```

---

## 第4课：如何让两个脚本说话

### 问题引出

在你的游戏里，脚本A需要告诉脚本B"玩家死了"，或者"分数增加了"。如果让A直接持有B的引用，会造成代码耦合。

更好的方法是使用**事件系统**：A发一个"玩家死了"的事件，谁想监听这个事件，谁就注册一下。

### 事件系统使用

**第一步：定义事件类型**

在 `EventCenter/E_EventType.cs` 文件中添加：

```csharp
public enum E_EventType 
{
    // 游戏状态事件
    E_Game_Start,
    E_Game_Over,
    
    // 玩家事件
    E_Player_Damaged,
    E_Player_Dead,
    E_Player_Jump,
    
    // 分数事件
    E_Score_Changed,
    
    // 可以添加自定义事件
    // E_Custom_Event,
}
```

**第二步：监听事件**

```csharp
// 文件名：ScoreUI.cs
// 监听分数变化事件
using UnityEngine;
using UnityEngine.UI;

public class ScoreUI : MonoBehaviour
{
    public Text scoreText;
    
    private void OnEnable()
    {
        // 注册分数变化事件
        EventCenter.Instance.AddEventListener<int>(E_EventType.E_Score_Changed, OnScoreChanged);
    }
    
    private void OnDisable()
    {
        // 退出时取消注册，防止内存泄漏
        EventCenter.Instance.RemoveEventListener<int>(E_EventType.E_Score_Changed, OnScoreChanged);
    }
    
    private void OnScoreChanged(int newScore)
    {
        scoreText.text = $"分数：{newScore}";
    }
}
```

**第三步：触发事件**

```csharp
// 文件名：Player.cs
// 当玩家得分时触发事件
using UnityEngine;

public class Player : MonoBehaviour
{
    private int score = 0;
    
    public void AddScore(int value)
    {
        score += value;
        
        // 触发分数变化事件，通知所有监听者
        EventCenter.Instance.EventTrigger<int>(E_EventType.E_Score_Changed, score);
    }
}
```

### 完整的事件通信示例

```csharp
// ==================== 事件类型定义 ====================
public enum E_GameEvent
{
    E_Player_Damaged,    // 玩家受伤，参数：伤害值
    E_Player_Healed,     // 玩家回血，参数：回血量
    E_Player_Dead,       // 玩家死亡，无参数
    E_Enemy_Killed,      // 敌人死亡，参数：击杀得分
    E_Coin_Collected,    // 金币收集，参数：金币数量
    E_Level_Complete,    // 关卡完成，无参数
}

// ==================== 玩家脚本 ====================
public class Player : MonoBehaviour
{
    public int hp = 100;
    public int maxHp = 100;
    
    public void TakeDamage(int damage)
    {
        hp -= damage;
        hp = Mathf.Max(0, hp);
        
        // 通知所有系统：玩家受伤了
        EventCenter.Instance.EventTrigger<int>(E_GameEvent.E_Player_Damaged, damage);
        
        if (hp <= 0)
        {
            Die();
        }
    }
    
    public void Heal(int amount)
    {
        hp += amount;
        hp = Mathf.Min(maxHp, hp);
        
        // 通知：玩家回血了
        EventCenter.Instance.EventTrigger<int>(E_GameEvent.E_Player_Healed, amount);
    }
    
    private void Die()
    {
        // 通知：玩家死亡了
        EventCenter.Instance.EventTrigger(E_GameEvent.E_Player_Dead);
    }
}

// ==================== 血条UI ====================
public class HealthBar : MonoBehaviour
{
    public Slider hpSlider;
    public Text hpText;
    
    private void OnEnable()
    {
        EventCenter.Instance.AddEventListener<int>(E_GameEvent.E_Player_Damaged, OnDamaged);
        EventCenter.Instance.AddEventListener<int>(E_GameEvent.E_Player_Healed, OnHealed);
    }
    
    private void OnDisable()
    {
        EventCenter.Instance.RemoveEventListener<int>(E_GameEvent.E_Player_Damaged, OnDamaged);
        EventCenter.Instance.RemoveEventListener<int>(E_GameEvent.E_Player_Healed, OnHealed);
    }
    
    private void OnDamaged(int damage)
    {
        UpdateHealthDisplay();
    }
    
    private void OnHealed(int amount)
    {
        UpdateHealthDisplay();
    }
    
    private void UpdateHealthDisplay()
    {
        // 这里的Player.Instance是你自己的玩家单例
        Player player = FindObjectOfType<Player>();
        if (player != null)
        {
            hpSlider.value = (float)player.hp / player.maxHp;
            hpText.text = $"{player.hp}/{player.maxHp}";
        }
    }
}

// ==================== 音效系统 ====================
public class AudioSystem : MonoBehaviour
{
    private void OnEnable()
    {
        EventCenter.Instance.AddEventListener<int>(E_GameEvent.E_Player_Damaged, OnPlayerHurt);
        EventCenter.Instance.AddEventListener(E_GameEvent.E_Player_Dead, OnPlayerDeath);
        EventCenter.Instance.AddEventListener<int>(E_GameEvent.E_Enemy_Killed, OnEnemyKilled);
    }
    
    private void OnDisable()
    {
        EventCenter.Instance.RemoveEventListener<int>(E_GameEvent.E_Player_Damaged, OnPlayerHurt);
        EventCenter.Instance.RemoveEventListener(E_GameEvent.E_Player_Dead, OnPlayerDeath);
        EventCenter.Instance.RemoveEventListener<int>(E_GameEvent.E_Enemy_Killed, OnEnemyKilled);
    }
    
    private void OnPlayerHurt(int damage)
    {
        MusicMgr.Instance.PlaySound("hurt");
    }
    
    private void OnPlayerDeath()
    {
        MusicMgr.Instance.PlaySound("game_over");
    }
    
    private void OnEnemyKilled(int score)
    {
        MusicMgr.Instance.PlaySound("enemy_death");
    }
}

// ==================== 敌人脚本 ====================
public class Enemy : MonoBehaviour
{
    public int scoreValue = 100;
    
    public void Die()
    {
        // 通知：敌人死亡
        EventCenter.Instance.EventTrigger<int>(E_GameEvent.E_Enemy_Killed, scoreValue);
        Destroy(gameObject);
    }
}
```

### 事件系统的注意事项

1. **记得取消注册**
```csharp
// 错误：忘记取消注册，会导致内存泄漏
void OnEnable()
{
    EventCenter.Instance.AddEventListener(...);
}

// 正确：OnDisable中取消注册
void OnEnable()
{
    EventCenter.Instance.AddEventListener(...);
}

void OnDisable()
{
    EventCenter.Instance.RemoveEventListener(...);
}
```

2. **场景切换时清理**
```csharp
// 在切换场景时，清理所有事件监听
public class SceneTransition : MonoBehaviour
{
    public void ChangeScene(string sceneName)
    {
        // 先清理
        EventCenter.Instance.Clear();
        
        // 再切换场景
        SceneMgr.Instance.LoadSceneAsyn(sceneName);
    }
}
```

3. **事件参数类型要一致**
```csharp
// 注册 int 参数的事件
EventCenter.Instance.AddEventListener<int>(E_EventType.E_Score_Changed, OnScoreChanged);

// 触发时也要是 int
EventCenter.Instance.EventTrigger<int>(E_EventType.E_Score_Changed, 100);
```

---

## 第5课：如何实现倒计时

### 定时器基础

游戏里经常需要倒计时功能，比如：
- 技能冷却
- 游戏限时
- BUFF持续时间
- 延迟执行

### TimerMgr使用

```csharp
// ==================== 技能冷却示例 ====================
public class SkillSystem : MonoBehaviour
{
    private int cooldownTimer;
    private bool isCooldown = false;
    public float cooldownTime = 5f;  // 冷却5秒
    public Image cooldownImage;  // 冷却图标
    
    private void Start()
    {
        // 创建一次性定时器（5秒后冷却完毕）
        cooldownTimer = TimerMgr.Instance.CreateTimer(
            isRealTime: false,        // false=受timeScale影响，true=不受影响
            allTime: (int)(cooldownTime * 1000),  // 毫秒
            overCallBack: () =>       // 定时结束回调
            {
                EndCooldown();
            }
        );
        
        // 初始暂停定时器
        TimerMgr.Instance.StopTimer(cooldownTimer);
    }
    
    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Q))
        {
            UseSkill();
        }
    }
    
    public void UseSkill()
    {
        if (isCooldown)
        {
            Debug.Log("技能还在冷却中！");
            return;
        }
        
        Debug.Log("释放技能！");
        // 释放技能的代码...
        
        // 开始冷却
        isCooldown = true;
        TimerMgr.Instance.StartTimer(cooldownTimer);
    }
    
    private void EndCooldown()
    {
        isCooldown = false;
        Debug.Log("技能冷却完毕！");
    }
}

// ==================== 游戏限时示例 ====================
public class GameTimer : MonoBehaviour
{
    private int gameTimer;
    public int gameDuration = 60;  // 60秒
    
    public Text timerText;
    
    private void Start()
    {
        // 创建循环定时器（每秒更新一次UI）
        gameTimer = TimerMgr.Instance.CreateTimer(
            isRealTime: true,         // 不受暂停影响
            allTime: gameDuration * 1000,
            overCallBack: () =>       // 时间到
            {
                GameOver();
            },
            intervalTime: 1000,       // 每秒触发一次
            callBack: () =>           // 每秒执行
            {
                UpdateTimerUI();
            }
        );
    }
    
    private void UpdateTimerUI()
    {
        // 获取剩余时间（毫秒转秒）
        int remaining = gameDuration * 1000 - TimerMgr.Instance.GetRemainingTime(gameTimer);
        int seconds = remaining / 1000;
        timerText.text = $"剩余时间：{seconds}秒";
    }
    
    private void GameOver()
    {
        Debug.Log("游戏时间到！");
        // 游戏结束逻辑
    }
    
    public void PauseGame()
    {
        TimerMgr.Instance.StopTimer(gameTimer);
    }
    
    public void ResumeGame()
    {
        TimerMgr.Instance.StartTimer(gameTimer);
    }
}

// ==================== BUFF系统示例 ====================
public class BuffSystem : MonoBehaviour
{
    private int buffTimer;
    private int buffTickTimer;
    
    public void ApplyBuff(string buffName, float duration, float tickInterval)
    {
        Debug.Log($"获得BUFF：{buffName}，持续{duration}秒");
        
        // 持续时间定时器
        buffTimer = TimerMgr.Instance.CreateTimer(
            isRealTime: false,
            allTime: (int)(duration * 1000),
            overCallBack: () =>
            {
                EndBuff(buffName);
            }
        );
        
        // 周期触发定时器（如每秒造成伤害）
        buffTickTimer = TimerMgr.Instance.CreateTimer(
            isRealTime: false,
            allTime: (int)(duration * 1000),
            overCallBack: null,
            intervalTime: (int)(tickInterval * 1000),
            callBack: () =>
            {
                OnBuffTick(buffName);
            }
        );
        
        // 启动定时器
        TimerMgr.Instance.StartTimer(buffTimer);
        TimerMgr.Instance.StartTimer(buffTickTimer);
    }
    
    private void OnBuffTick(string buffName)
    {
        Debug.Log($"{buffName}效果触发！");
        // 周期效果的代码
    }
    
    private void EndBuff(string buffName)
    {
        Debug.Log($"{buffName}效果结束");
        // 移除定时器
        TimerMgr.Instance.RemoveTimer(buffTimer);
        TimerMgr.Instance.RemoveTimer(buffTickTimer);
    }
}
```

### 定时器参数说明

```csharp
// CreateTimer 参数说明
int timerId = TimerMgr.Instance.CreateTimer(
    isRealTime:      bool,      // true=不受timeScale影响，false=受影响
    allTime:         int,       // 总时间（毫秒）
    overCallBack:    UnityAction,   // 定时结束回调
    intervalTime:    int = 0,   // 间隔时间（毫秒），0表示没有间隔回调
    callBack:        UnityAction = null  // 间隔回调
);

// 定时器控制
TimerMgr.Instance.StartTimer(timerId);   // 启动
TimerMgr.Instance.StopTimer(timerId);    // 暂停
TimerMgr.Instance.ResetTimer(timerId);   // 重置
TimerMgr.Instance.RemoveTimer(timerId);  // 移除
```

### 定时器使用场景速查

| 场景 | isRealTime | intervalTime | 说明 |
|------|------------|--------------|------|
| 技能冷却 | false | 0 | 受游戏暂停影响 |
| 游戏倒计时 | true | 1000 | 不受暂停影响，每秒更新 |
| BUFF持续 | false | 1000 | 受暂停影响，每秒触发 |
| 延时执行 | false | 0 | 简单的延时 |
| 实时计时器 | true | 100 | 精确计时，不受任何影响 |

---

## 第6课：如何制作界面UI

### UI管理基础

游戏里的界面（分数、血条、按钮等）需要一个统一的管理方式。框架提供了UIMgr来管理所有UI面板。

### 创建UI面板

**第一步：创建面板物体**

1. 在Hierarchy右键 → UI → Panel，创建面板
2. 或者直接创建空物体，挂载面板脚本

**第二步：编写面板脚本**

```csharp
// 文件名：MainMenuPanel.cs
// 继承BasePanel，框架会自动查找子控件
using UnityEngine;
using UnityEngine.UI;

public class MainMenuPanel : BasePanel
{
    // 框架会自动查找这些控件
    private Button startButton;
    private Button settingsButton;
    private Button quitButton;
    private Slider volumeSlider;
    private Text versionText;
    
    protected override void Awake()
    {
        base.Awake();
        
        // 获取控件（名称必须和Hierarchy中的物体名一致）
        startButton = GetControl<Button>("StartButton");
        settingsButton = GetControl<Button>("SettingsButton");
        quitButton = GetControl<Button>("QuitButton");
        volumeSlider = GetControl<Slider>("VolumeSlider");
        versionText = GetControl<Text>("VersionText");
        
        // 添加按钮事件
        startButton.onClick.AddListener(OnStartClick);
        settingsButton.onClick.AddListener(OnSettingsClick);
        quitButton.onClick.AddListener(OnQuitClick);
        
        // 滑条事件
        volumeSlider.onValueChanged.AddListener(OnVolumeChange);
    }
    
    // 显示面板时调用
    public override void ShowMe()
    {
        gameObject.SetActive(true);
        versionText.text = $"版本：1.0.0";
    }
    
    // 隐藏面板时调用
    public override void HideMe()
    {
        gameObject.SetActive(false);
    }
    
    // 按钮回调
    private void OnStartClick()
    {
        Debug.Log("点击了开始按钮");
        // 进入游戏
        UIMgr.Instance.HidePanel<MainMenuPanel>();
        UIMgr.Instance.ShowPanel<GamePanel>(E_UILayer.Middle);
    }
    
    private void OnSettingsClick()
    {
        Debug.Log("点击了设置按钮");
        UIMgr.Instance.ShowPanel<SettingsPanel>(E_UILayer.Top);
    }
    
    private void OnQuitClick()
    {
        Debug.Log("点击了退出按钮");
        Application.Quit();
    }
    
    private void OnVolumeChange(float value)
    {
        // 调整音量
        MusicMgr.Instance.ChangeBKMusicValue(value);
        MusicMgr.Instance.ChangeSoundValue(value);
    }
}
```

**第三步：使用面板**

```csharp
// 文件名：UIController.cs
using UnityEngine;

public class UIController : MonoBehaviour
{
    private void Start()
    {
        // 显示主菜单面板（默认在Middle层级）
        UIMgr.Instance.ShowPanel<MainMenuPanel>(E_UILayer.Middle, (panel) =>
        {
            Debug.Log("主菜单面板显示完成！");
        });
    }
    
    // 显示设置面板
    public void ShowSettings()
    {
        UIMgr.Instance.ShowPanel<SettingsPanel>(E_UILayer.Top);
    }
    
    // 隐藏当前面板
    public void HideCurrentPanel()
    {
        UIMgr.Instance.HidePanel<MainMenuPanel>();
        // 或销毁面板
        // UIMgr.Instance.HidePanel<MainMenuPanel>(true);
    }
    
    // 获取已显示的面板
    public void UpdatePanel()
    {
        UIMgr.Instance.GetPanel<MainMenuPanel>((panel) =>
        {
            if (panel != null)
            {
                // 面板已显示，可以更新它
                panel.UpdateDisplay();
            }
        });
    }
}
```

### UI层级说明

框架定义了四个UI层级，从下到上：

```csharp
// 层级说明
E_UILayer.Bottom   // 最低层，背景等
E_UILayer.Middle   // 中间层，主面板
E_UILayer.Top      // 上层，弹窗
E_UILayer.System   // 最高层，系统界面
```

**使用示例：**

```csharp
// 主界面放在Middle
UIMgr.Instance.ShowPanel<MainMenuPanel>(E_UILayer.Middle);

// 弹窗放在Top（在主界面上方）
UIMgr.Instance.ShowPanel<ConfirmDialog>(E_UILayer.Top);

// 系统设置放在System（最高层）
UIMgr.Instance.ShowPanel<SettingsPanel>(E_UILayer.System);
```

### 完整UI面板示例

```csharp
// ==================== 设置面板 ====================
public class SettingsPanel : BasePanel
{
    private Slider bgmSlider;
    private Slider sfxSlider;
    private Toggle fullscreenToggle;
    private Dropdown qualityDropdown;
    private Button confirmButton;
    private Button cancelButton;
    
    // 存储原始设置
    private float originalBgmVolume;
    private float originalSfxVolume;
    private bool originalFullscreen;
    
    protected override void Awake()
    {
        base.Awake();
        
        bgmSlider = GetControl<Slider>("BGMSlider");
        sfxSlider = GetControl<Slider>("SFXSlider");
        fullscreenToggle = GetControl<Toggle>("FullscreenToggle");
        qualityDropdown = GetControl<Dropdown>("QualityDropdown");
        confirmButton = GetControl<Button>("ConfirmButton");
        cancelButton = GetControl<Button>("CancelButton");
        
        confirmButton.onClick.AddListener(OnConfirm);
        cancelButton.onClick.AddListener(OnCancel);
        
        bgmSlider.onValueChanged.AddListener(OnBgmChange);
        sfxSlider.onValueChanged.AddListener(OnSfxChange);
    }
    
    public override void ShowMe()
    {
        gameObject.SetActive(true);
        
        // 恢复当前设置到UI
        bgmSlider.value = MusicMgr.Instance.bkMusicValue;
        sfxSlider.value = MusicMgr.Instance.soundValue;
        fullscreenToggle.isOn = Screen.fullScreen;
        
        // 保存原始设置（用于取消）
        originalBgmVolume = MusicMgr.Instance.bkMusicValue;
        originalSfxVolume = MusicMgr.Instance.soundValue;
        originalFullscreen = Screen.fullScreen;
    }
    
    public override void HideMe()
    {
        gameObject.SetActive(false);
    }
    
    private void OnBgmChange(float value)
    {
        MusicMgr.Instance.ChangeBKMusicValue(value);
    }
    
    private void OnSfxChange(float value)
    {
        MusicMgr.Instance.ChangeSoundValue(value);
    }
    
    private void OnConfirm()
    {
        // 保存设置
        PlayerPrefs.SetFloat("BGMVolume", bgmSlider.value);
        PlayerPrefs.SetFloat("SFXVolume", sfxSlider.value);
        PlayerPrefs.SetInt("FullScreen", fullscreenToggle.isOn ? 1 : 0);
        
        // 应用设置
        Screen.fullScreen = fullscreenToggle.isOn;
        
        HideMe();
    }
    
    private void OnCancel()
    {
        // 恢复原始设置
        MusicMgr.Instance.ChangeBKMusicValue(originalBgmVolume);
        MusicMgr.Instance.ChangeSoundValue(originalSfxVolume);
        Screen.fullScreen = originalFullscreen;
        
        HideMe();
    }
}

// ==================== 确认对话框 ====================
public class ConfirmDialog : BasePanel
{
    private Text messageText;
    private Button confirmButton;
    private Button cancelButton;
    private System.Action onConfirm;
    private System.Action onCancel;
    
    protected override void Awake()
    {
        base.Awake();
        
        messageText = GetControl<Text>("MessageText");
        confirmButton = GetControl<Button>("ConfirmButton");
        cancelButton = GetControl<Button>("CancelButton");
        
        confirmButton.onClick.AddListener(OnConfirmClick);
        cancelButton.onClick.AddListener(OnCancelClick);
    }
    
    public override void ShowMe()
    {
        gameObject.SetActive(true);
    }
    
    public override void HideMe()
    {
        gameObject.SetActive(false);
    }
    
    // 显示确认对话框（静态方法方便调用）
    public static void Show(string message, System.Action confirmCallback, System.Action cancelCallback = null)
    {
        UIMgr.Instance.ShowPanel<ConfirmDialog>(E_UILayer.Top, (dialog) =>
        {
            dialog.messageText.text = message;
            dialog.onConfirm = confirmCallback;
            dialog.onCancel = cancelCallback;
        });
    }
    
    private void OnConfirmClick()
    {
        onConfirm?.Invoke();
        HideMe();
    }
    
    private void OnCancelClick()
    {
        onCancel?.Invoke();
        HideMe();
    }
}

// 使用确认对话框
public class Example : MonoBehaviour
{
    public void OnQuitClick()
    {
        ConfirmDialog.Show(
            "确定要退出游戏吗？",
            () =>  // 确认回调
            {
                Application.Quit();
            },
            () =>  // 取消回调
            {
                Debug.Log("取消退出");
            }
        );
    }
}
```

### 新手常见问题

**问题1：GetControl返回null**

```csharp
// 检查1：控件名称是否正确
// Hierarchy中物体名必须和GetControl中的名称完全一致
// "StartButton" 和 "startbutton" 不一样

// 检查2：是否调用了base.Awake()
protected override void Awake()
{
    base.Awake();  // 必须调用
}

// 检查3：面板是否激活
public override void ShowMe()
{
    gameObject.SetActive(true);  // 必须激活
}
```

**问题2：按钮事件不触发**

```csharp
// 检查：onClick是否添加了监听
startButton.onClick.AddListener(OnStartClick);  // 必须添加

// 检查：方法签名是否正确
private void OnStartClick()  // 必须是无参方法
{
    // ...
}
```

---

## 第7课：如何播放音效和音乐

### 音频管理基础

游戏里的声音分为两种：
- **背景音乐（BGM）**：一直播放的循环音乐
- **音效（Sound）**：短促的一次性声音，如点击、爆炸

### MusicMgr使用

```csharp
// ==================== 背景音乐 ====================
public class BGMController : MonoBehaviour
{
    private void Start()
    {
        // 播放背景音乐
        MusicMgr.Instance.PlayBKMusic("main_theme");
        
        // 设置音量（0-1）
        MusicMgr.Instance.ChangeBKMusicValue(0.5f);
    }
    
    // 暂停背景音乐
    public void PauseBGM()
    {
        MusicMgr.Instance.PauseBKMusic();
    }
    
    // 继续播放
    public void ResumeBGM()
    {
        MusicMgr.Instance.PlayBKMusic("main_theme");  // 重新播放
    }
    
    // 停止背景音乐
    public void StopBGM()
    {
        MusicMgr.Instance.StopBKMusic();
    }
}

// ==================== 音效播放 ====================
public class SoundController : MonoBehaviour
{
    private void Update()
    {
        // 点击播放音效
        if (Input.GetMouseButtonDown(0))
        {
            PlayClickSound();
        }
        
        // 跳跃播放音效
        if (Input.GetKeyDown(KeyCode.Space))
        {
            PlayJumpSound();
        }
    }
    
    private void PlayClickSound()
    {
        // 播放点击音效
        MusicMgr.Instance.PlaySound("click");
    }
    
    private void PlayJumpSound()
    {
        // 播放跳跃音效
        MusicMgr.Instance.PlaySound("jump");
    }
    
    // 播放循环音效（如环境音）
    private void PlayAmbientSound()
    {
        MusicMgr.Instance.PlaySound("wind", isLoop: true);
    }
    
    // 停止指定音效
    private AudioSource currentAmbient;
    
    private void PlayAndStopAmbient()
    {
        MusicMgr.Instance.PlaySound("wind", isLoop: true, callBack: (source) =>
        {
            currentAmbient = source;
        });
        
        // 之后可以停止
        // MusicMgr.Instance.StopSound(currentAmbient);
    }
}

// ==================== 音量控制 ====================
public class VolumeControl : MonoBehaviour
{
    public Slider bgmSlider;
    public Slider sfxSlider;
    
    private void Start()
    {
        bgmSlider.onValueChanged.AddListener(OnBgmVolumeChange);
        sfxSlider.onValueChanged.AddListener(OnSfxVolumeChange);
        
        // 初始化音量显示
        bgmSlider.value = MusicMgr.Instance.bkMusicValue;
        sfxSlider.value = MusicMgr.Instance.soundValue;
    }
    
    private void OnBgmVolumeChange(float value)
    {
        MusicMgr.Instance.ChangeBKMusicValue(value);
    }
    
    private void OnSfxVolumeChange(float value)
    {
        MusicMgr.Instance.ChangeSoundValue(value);
    }
    
    // 静音切换
    public void ToggleMute()
    {
        MusicMgr.Instance.ChangeBKMusicValue(0);
        MusicMgr.Instance.ChangeSoundValue(0);
    }
}

// ==================== 游戏事件与音效 ====================
public class GameAudio : MonoBehaviour
{
    private void OnEnable()
    {
        // 监听游戏事件，播放对应音效
        EventCenter.Instance.AddEventListener(E_GameEvent.E_Player_Jump, OnPlayerJump);
        EventCenter.Instance.AddEventListener(E_GameEvent.E_Player_Damaged, OnPlayerDamaged);
        EventCenter.Instance.AddEventListener(E_GameEvent.E_Enemy_Killed, OnEnemyKilled);
        EventCenter.Instance.AddEventListener(E_GameEvent.E_Coin_Collected, OnCoinCollected);
    }
    
    private void OnDisable()
    {
        EventCenter.Instance.RemoveEventListener(E_GameEvent.E_Player_Jump, OnPlayerJump);
        EventCenter.Instance.RemoveEventListener(E_GameEvent.E_Player_Damaged, OnPlayerDamaged);
        EventCenter.Instance.RemoveEventListener(E_GameEvent.E_Enemy_Killed, OnEnemyKilled);
        EventCenter.Instance.RemoveEventListener(E_GameEvent.E_Coin_Collected, OnCoinCollected);
    }
    
    private void OnPlayerJump()
    {
        MusicMgr.Instance.PlaySound("jump");
    }
    
    private void OnPlayerDamaged(int damage)
    {
        if (damage > 20)
            MusicMgr.Instance.PlaySound("heavy_damage");
        else
            MusicMgr.Instance.PlaySound("light_damage");
    }
    
    private void OnEnemyKilled(int score)
    {
        MusicMgr.Instance.PlaySound("enemy_death");
    }
    
    private void OnCoinCollected(int amount)
    {
        MusicMgr.Instance.PlaySound("coin");
    }
}

// ==================== 清理音效 ====================
public class AudioCleaner : MonoBehaviour
{
    private void OnDestroy()
    {
        // 清理音效（场景切换时）
        MusicMgr.Instance.ClearSound();
    }
}
```

### 音效使用场景速查

| 场景 | 方法 | 参数 |
|------|------|------|
| 播放背景音乐 | `PlayBKMusic(name)` | 音乐名称 |
| 停止背景音乐 | `StopBKMusic()` | - |
| 播放一次音效 | `PlaySound(name)` | 音效名称 |
| 循环播放音效 | `PlaySound(name, isLoop: true)` | 音效名称，是否循环 |
| 调整背景音乐音量 | `ChangeBKMusicValue(value)` | 0-1 |
| 调整音效音量 | `ChangeSoundValue(value)` | 0-1 |
| 暂停所有音效 | `PlayOrPauseSound(false)` | - |
| 恢复所有音效 | `PlayOrPauseSound(true)` | - |
| 清理所有音效 | `ClearSound()` | - |

---

## 第8课：如何处理玩家输入

### 输入管理基础

游戏需要处理键盘、鼠标、手柄等输入。框架提供了InputMgr来统一管理输入。

### InputMgr使用

```csharp
// ==================== 输入配置 ====================
public class InputConfig : MonoBehaviour
{
    private void Start()
    {
        // 开启输入系统
        InputMgr.Instance.StartOrCloseInputMgr(true);
        
        // 配置键盘按键
        InputMgr.Instance.ChangeKeyboardInfo(
            E_GameEvent.E_Jump,           // 事件类型
            KeyCode.Space,                // 按键
            InputInfo.E_InputType.Down    // 按下触发
        );
        
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_Attack, KeyCode.J, InputInfo.E_InputType.Down);
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_Skill1, KeyCode.Q, InputInfo.E_InputType.Down);
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_Skill2, KeyCode.W, InputInfo.E_InputType.Down);
        
        // 配置鼠标
        InputMgr.Instance.ChangeMouseInfo(E_GameEvent.E_Fire, 0, InputInfo.E_InputType.Down);  // 左键
        InputMgr.Instance.ChangeMouseInfo(E_GameEvent.E_Aim, 1, InputInfo.E_InputType.Down);   // 右键
        
        // 持续按键（如移动）
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_MoveForward, KeyCode.W, InputInfo.E_InputType.Always);
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_MoveBackward, KeyCode.S, InputInfo.E_InputType.Always);
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_MoveLeft, KeyCode.A, InputInfo.E_InputType.Always);
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_MoveRight, KeyCode.D, InputInfo.E_InputType.Always);
    }
    
    private void OnDestroy()
    {
        // 关闭输入系统
        InputMgr.Instance.StartOrCloseInputMgr(false);
    }
}

// ==================== 监听输入事件 ====================
public class PlayerController : MonoBehaviour
{
    private void OnEnable()
    {
        // 监听跳跃
        EventCenter.Instance.AddEventListener(E_GameEvent.E_Jump, OnJump);
        
        // 监听攻击
        EventCenter.Instance.AddEventListener(E_GameEvent.E_Attack, OnAttack);
        
        // 监听移动（持续按键）
        EventCenter.Instance.AddEventListener<float>(E_GameEvent.E_Input_Horizontal, OnHorizontalMove);
        EventCenter.Instance.AddEventListener<float>(E_GameEvent.E_Input_Vertical, OnVerticalMove);
    }
    
    private void OnDisable()
    {
        EventCenter.Instance.RemoveEventListener(E_GameEvent.E_Jump, OnJump);
        EventCenter.Instance.RemoveEventListener(E_GameEvent.E_Attack, OnAttack);
        EventCenter.Instance.RemoveEventListener<float>(E_GameEvent.E_Input_Horizontal, OnHorizontalMove);
        EventCenter.Instance.RemoveEventListener<float>(E_GameEvent.E_Input_Vertical, OnVerticalMove);
    }
    
    private void OnJump()
    {
        Debug.Log("跳跃！");
        // 跳跃逻辑
    }
    
    private void OnAttack()
    {
        Debug.Log("攻击！");
        // 攻击逻辑
    }
    
    private void OnHorizontalMove(float value)
    {
        // value范围 -1 到 1
        Debug.Log($"水平移动：{value}");
    }
    
    private void OnVerticalMove(float value)
    {
        // value范围 -1 到 1
        Debug.Log($"垂直移动：{value}");
    }
}

// ==================== 键盘移动示例 ====================
public class KeyboardMovement : MonoBehaviour
{
    public float moveSpeed = 5f;
    
    private void Update()
    {
        // 方式1：直接使用Unity输入
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");
        Vector3 move = new Vector3(h, 0, v) * moveSpeed * Time.deltaTime;
        transform.Translate(move);
        
        // 方式2：通过InputMgr的事件
        // 在InputConfig中配置了E_Input_Horizontal和E_Input_Vertical事件
        // 这里不需要写Update里的代码，由事件驱动
    }
}

// ==================== 鼠标控制 ====================
public class MouseControl : MonoBehaviour
{
    private void OnEnable()
    {
        EventCenter.Instance.AddEventListener(E_GameEvent.E_Fire, OnFire);
        EventCenter.Instance.AddEventListener(E_GameEvent.E_Aim, OnAim);
    }
    
    private void OnFire()
    {
        Debug.Log("鼠标左键点击，开火！");
        // 开火逻辑
    }
    
    private void OnAim()
    {
        Debug.Log("鼠标右键瞄准");
        // 瞄准逻辑
    }
}

// ==================== 完整输入系统 ====================
public class CompleteInputSystem : MonoBehaviour
{
    // 输入映射配置
    private void SetupInputMapping()
    {
        // 移动
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_MoveForward, KeyCode.W, InputInfo.E_InputType.Always);
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_MoveBackward, KeyCode.S, InputInfo.E_InputType.Always);
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_MoveLeft, KeyCode.A, InputInfo.E_InputType.Always);
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_MoveRight, KeyCode.D, InputInfo.E_InputType.Always);
        
        // 动作
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_Jump, KeyCode.Space, InputInfo.E_InputType.Down);
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_Attack, KeyCode.J, InputInfo.E_InputType.Down);
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_Dash, KeyCode.K, InputInfo.E_InputType.Down);
        InputMgr.Instance.ChangeKeyboardInfo(E_GameEvent.E_Skill, KeyCode.L, InputInfo.E_InputType.Down);
        
        // 鼠标
        InputMgr.Instance.ChangeMouseInfo(E_GameEvent.E_Fire, 0, InputInfo.E_InputType.Down);
        InputMgr.Instance.ChangeMouseInfo(E_GameEvent.E_Aim, 1, InputInfo.E_InputType.Always);
    }
    
    // 启用/禁用输入
    public void EnableInput(bool enable)
    {
        InputMgr.Instance.StartOrCloseInputMgr(enable);
    }
}
```

### 输入类型说明

```csharp
// 输入触发类型
InputInfo.E_InputType.Down    // 按下时触发一次
InputInfo.E_InputType.Up      // 松开时触发一次
InputInfo.E_InputType.Always  // 按住期间每帧都触发
```

### 常用按键速查

| 功能 | 键盘 | 鼠标 |
|------|------|------|
| 移动 | W/A/S/D | - |
| 跳跃 | Space | - |
| 攻击 | J | 左键 |
| 技能1 | Q | - |
| 技能2 | E | - |
| 闪避 | K | - |
| 瞄准 | - | 右键 |
| 交互 | F | - |
| 暂停 | Escape | - |

---

## 第9课：如何切换场景

### 场景管理基础

游戏从标题画面进入游戏，或者从第一关进入第二关，都需要切换场景。

### SceneMgr使用

```csharp
// ==================== 场景切换 ====================
public class SceneController : MonoBehaviour
{
    // 同步切换（不推荐，会卡顿）
    public void LoadGameScene()
    {
        SceneMgr.Instance.LoadScene("GameScene", () =>
        {
            Debug.Log("场景加载完成！");
        });
    }
    
    // 异步切换（推荐，有加载进度）
    public void LoadNextLevel()
    {
        SceneMgr.Instance.LoadSceneAsyn("Level2", () =>
        {
            Debug.Log("第二关加载完成！");
            // 初始化新场景
            InitNewLevel();
        });
    }
    
    private void InitNewLevel()
    {
        // 新场景的初始化代码
    }
}

// ==================== 加载界面 ====================
public class LoadingScreen : MonoBehaviour
{
    public Slider progressBar;
    public Text progressText;
    public GameObject loadingPanel;
    
    public void ShowLoading(string sceneName)
    {
        loadingPanel.SetActive(true);
        
        // 监听加载进度
        EventCenter.Instance.AddEventListener<float>(E_GameEvent.E_LoadProgress, OnProgressUpdate);
        
        // 开始加载
        SceneMgr.Instance.LoadSceneAsyn(sceneName, () =>
        {
            // 加载完成
            loadingPanel.SetActive(false);
            EventCenter.Instance.RemoveEventListener<float>(E_GameEvent.E_LoadProgress, OnProgressUpdate);
            Debug.Log("场景加载完成！");
        });
    }
    
    private void OnProgressUpdate(float progress)
    {
        // progress范围 0-1
        progressBar.value = progress;
        progressText.text = $"加载中... {(progress * 100):F0}%";
    }
    
    // 从主菜单进入游戏
    public void PlayGame()
    {
        ShowLoading("MainGame");
    }
    
    // 重新开始
    public void RestartGame()
    {
        ShowLoading(UnityEngine.SceneManagement.SceneManager.GetActiveScene().name);
    }
}

// ==================== 场景切换时清理 ====================
public class SceneCleanup : MonoBehaviour
{
    public void ChangeScene(string sceneName)
    {
        // 清理事件
        EventCenter.Instance.Clear();
        
        // 清理定时器
        TimerMgr.Instance.Stop();
        
        // 清理音效
        MusicMgr.Instance.ClearSound();
        
        // 清理对象池
        PoolMgr.Instance.ClearPool();
        
        // 切换场景
        SceneMgr.Instance.LoadSceneAsyn(sceneName, () =>
        {
            Debug.Log("进入新场景！");
        });
    }
}
```

### 场景切换与事件

```csharp
// 在场景加载完成时触发事件
public class SceneEvents : MonoBehaviour
{
    private void Start()
    {
        // 监听场景加载完成事件
        EventCenter.Instance.AddEventListener(E_GameEvent.E_SceneLoaded, OnSceneLoaded);
    }
    
    private void OnSceneLoaded()
    {
        string sceneName = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;
        Debug.Log($"进入场景：{sceneName}");
        
        // 根据场景做不同的事
        switch (sceneName)
        {
            case "MainMenu":
                PlayMainMenuMusic();
                break;
            case "GameLevel1":
                PlayGameMusic();
                break;
        }
    }
    
    private void PlayMainMenuMusic()
    {
        MusicMgr.Instance.PlayBKMusic("menu_bgm");
    }
    
    private void PlayGameMusic()
    {
        MusicMgr.Instance.PlayBKMusic("game_bgm");
    }
}
```

---

## 第10课：常用工具函数

### MathUtil - 数学工具

```csharp
// ==================== 角度转换 ====================
public class AngleExample : MonoBehaviour
{
    private void Start()
    {
        // 角度转弧度
        float rad = MathUtil.Deg2Rad(45f);  // 45度转弧度
        
        // 弧度转角度
        float deg = MathUtil.Rad2Deg(Mathf.PI / 4f);  // 弧度转角度
    }
}

// ==================== 距离计算 ====================
public class DistanceExample : MonoBehaviour
{
    public Transform player;
    public Transform enemy;
    
    private void Update()
    {
        // XZ平面距离（忽略高度差）
        float distanceXZ = MathUtil.GetObjDistanceXZ(player.position, enemy.position);
        
        // XY平面距离（忽略深度差）
        float distanceXY = MathUtil.GetObjDistanceXY(player.position, enemy.position);
        
        // 判断是否在范围内
        bool isNear = MathUtil.CheckObjDistanceXZ(player.position, enemy.position, 5f);
    }
}

// ==================== 射线检测 ====================
public class RaycastExample : MonoBehaviour
{
    private Camera mainCamera;
    
    private void Start()
    {
        mainCamera = Camera.main;
    }
    
    private void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            // 从鼠标位置发射射线
            Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);
            
            // 检测是否击中敌人
            MathUtil.RayCast<Enemy>(ray, (enemy) =>
            {
                if (enemy != null)
                {
                    Debug.Log($"击中敌人：{enemy.name}");
                    enemy.TakeDamage(100);
                }
            }, 100f, LayerMask.GetMask("Enemy"));
        }
    }
}

// ==================== 范围检测 ====================
public class OverlapExample : MonoBehaviour
{
    public Transform centerPoint;
    public float radius = 5f;
    
    private void Update()
    {
        // 检测范围内的敌人
        MathUtil.OverlapSphere<Enemy>(centerPoint.position, radius, LayerMask.GetMask("Enemy"), (enemy) =>
        {
            Debug.Log($"范围内有敌人：{enemy.name}");
        });
    }
}
```

### TextUtil - 字符串工具

```csharp
// ==================== 字符串分割 ====================
public class StringExample : MonoBehaviour
{
    private void Start()
    {
        // 分号分割
        string str1 = "item1;item2;item3";
        string[] items = TextUtil.SplitStr(str1, 1);  // type=1是分号
        
        // 逗号分割
        string str2 = "1,2,3,4,5";
        int[] nums = TextUtil.SplitStrToIntArr(str2, 2);  // type=2是逗号
        
        // 双重分割（键值对）
        TextUtil.SplitStrToIntArrTwice("1=100;2=200", 1, 4, (key, value) =>
        {
            Debug.Log($"键：{key}，值：{value}");
        });
    }
}

// ==================== 数值格式化 ====================
public class FormatExample : MonoBehaviour
{
    private void Start()
    {
        // 数字补零
        string numStr = TextUtil.GetNumStr(5, 3);  // "005"
        string numStr2 = TextUtil.GetNumStr(12, 4);  // "0012"
        
        // 小数位数
        string decimalStr = TextUtil.GetDecimalStr(3.14159f, 2);  // "3.14"
        string decimalStr2 = TextUtil.GetDecimalStr(3.14159f, 3);  // "3.142"
        
        // 大数字显示
        string bigNum = TextUtil.GetBigDataToString(12345);  // "1万2345"
        string bigNum2 = TextUtil.GetBigDataToString(123456789);  // "1亿2345万6789"
    }
}

// ==================== 时间格式化 ====================
public class TimeFormatExample : MonoBehaviour
{
    private void Start()
    {
        // 时分秒格式
        string hms = TextUtil.SecondToHMS(3661, false, false, "时", "分", "秒");
        // 结果："1时1分1秒"
        
        // 简化格式
        string hms2 = TextUtil.SecondToHMS2(3661);
        // 结果："01:01:01"
        
        // 不显示0
        string hms3 = TextUtil.SecondToHMS(65, true, false, "时", "分", "秒");
        // 结果："1分5秒"
        
        // 保持两位
        string hms4 = TextUtil.SecondToHMS(65, false, true, ":", ":", "");
        // 结果："00:01:05"
    }
}
```

### EncryptionUtil - 加密工具

```csharp
// ==================== 存档加密 ====================
public class SaveData : MonoBehaviour
{
    public void SaveGame()
    {
        // 生成密钥
        int key = EncryptionUtil.GetRandomKey();
        
        // 加密数据
        int encryptedScore = EncryptionUtil.LockValue(Player.Score, key);
        int encryptedHp = EncryptionUtil.LockValue(Player.HP, key);
        
        // 保存到PlayerPrefs
        PlayerPrefs.SetInt("SaveKey", key);
        PlayerPrefs.SetInt("SaveScore", encryptedScore);
        PlayerPrefs.SetInt("SaveHP", encryptedHp);
        PlayerPrefs.Save();
        
        Debug.Log("存档已保存！");
    }
    
    public void LoadGame()
    {
        if (!PlayerPrefs.HasKey("SaveKey"))
        {
            Debug.Log("没有存档！");
            return;
        }
        
        // 读取密钥
        int key = PlayerPrefs.GetInt("SaveKey");
        
        // 读取并解密
        int score = EncryptionUtil.UnLoackValue(PlayerPrefs.GetInt("SaveScore"), key);
        int hp = EncryptionUtil.UnLoackValue(PlayerPrefs.GetInt("SaveHP"), key);
        
        Player.Score = score;
        Player.HP = hp;
        
        Debug.Log($"读取存档！分数：{score}，血量：{hp}");
    }
}
```

---

## 常见问题急救箱

### 问题1：程序启动时卡住或报错

**症状**：播放游戏时报错或卡住不动

**解决方法**：
```csharp
// 检查1：是否有空引用
void Start()
{
    // 如果SomeObject是null，这里会报错
    SomeObject.DoSomething();
}

// 解决：加空判断
void Start()
{
    if (SomeObject != null)
    {
        SomeObject.DoSomething();
    }
}

// 检查2：是否在Awake中访问了未初始化的单例
void Awake()
{
    // 可能有问题
    PoolMgr.Instance.ClearPool();
}

// 解决：在Start中访问
void Start()
{
    PoolMgr.Instance.ClearPool();
}
```

### 问题2：物体不动

**症状**：物体创建后不动

**解决方法**：
```csharp
// 检查1：是否有Rigidbody
// 如果要移动带物理的物体，应该用velocity或AddForce
void MoveWithPhysics()
{
    GetComponent<Rigidbody>().velocity = Vector3.forward * speed;
}

// 而不是
void MoveWrong()
{
    transform.Translate(Vector3.forward * speed);  // 物理物体这样移动不对
}

// 检查2：Update是否执行
void Update()
{
    // 如果游戏暂停了，Update还在运行
    // 检查timeScale
    Debug.Log($"Time.timeScale = {Time.timeScale}");
}

// 检查3：物体是否active
void CheckActive()
{
    if (gameObject.activeInHierarchy == false)
    {
        Debug.Log("物体未激活！");
    }
}
```

### 问题3：事件不响应

**症状**：注册了事件但回调不执行

**解决方法**：
```csharp
// 检查1：事件类型是否一致
// 注册
EventCenter.Instance.AddEventListener<int>(E_GameEvent.E_Score, OnScore);

// 触发
EventCenter.Instance.EventTrigger<int>(E_GameEvent.E_Score, 100);  // 对

// 检查2：是否在OnEnable中注册，OnDisable中注销
void OnEnable()
{
    EventCenter.Instance.AddEventListener<int>(E_GameEvent.E_Score, OnScore);
}

void OnDisable()
{
    EventCenter.Instance.RemoveEventListener<int>(E_GameEvent.E_Score, OnScore);
}

// 检查3：场景切换后要重新注册
void OnSceneLoaded()
{
    EventCenter.Instance.AddEventListener<int>(E_GameEvent.E_Score, OnScore);
}
```

### 问题4：UI显示异常

**症状**：UI不显示或显示位置不对

**解决方法**：
```csharp
// 检查1：Canvas的Render Mode
// Screen Space - Overlay：UI在最上层
// Screen Space - Camera：需要指定相机
// World Space：UI在3D空间中

// 检查2：Canvas Scaler设置
// UI Scale Mode: Scale With Screen Size
// Reference Resolution: 1920 x 1080

// 检查3：RectTransform
// 检查anchors、pivot设置是否正确

// 检查4：UI物体是否active
void CheckUI()
{
    if (gameObject.activeSelf == false)
    {
        gameObject.SetActive(true);
    }
}
```

### 问题5：音效没声音

**症状**：播放音效但听不到

**解决方法**：
```csharp
// 检查1：AudioSource组件
// 物体上必须有AudioSource组件

// 检查2：AudioClip不为null
void PlaySound()
{
    if (clip == null)
    {
        Debug.LogError("AudioClip未赋值！");
        return;
    }
    MusicMgr.Instance.PlaySound("click");
}

// 检查3：音量是否为0
void CheckVolume()
{
    Debug.Log($"BGM音量：{MusicMgr.Instance.bkMusicValue}");
    Debug.Log($"音效音量：{MusicMgr.Instance.soundValue}");
}

// 检查4：AudioListener
// 场景中只能有一个AudioListener，通常挂在Main Camera上
```

### 问题6：内存越来越大

**症状**：游戏玩久了变卡

**解决方法**：
```csharp
// 检查1：场景切换时清理
void OnSceneChange(string sceneName)
{
    EventCenter.Instance.Clear();
    TimerMgr.Instance.Stop();
    MusicMgr.Instance.ClearSound();
    PoolMgr.Instance.ClearPool();
    ResMgr.Instance.UnloadUnusedAssets(null);
}

// 检查2：避免在Update中创建对象
// 错误
void Update()
{
    GameObject obj = new GameObject("temp");  // 每帧创建！
}

// 正确：复用对象
private GameObject tempObj;

void Start()
{
    tempObj = new GameObject("temp");
}

void Update()
{
    // 复用tempObj
}

// 检查3：使用对象池
public class BulletSpawner : MonoBehaviour
{
    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            // 用对象池，不用Instantiate
            Bullet bullet = PoolMgr.Instance.GetObj<Bullet>("Bullet");
        }
    }
}
```

### 问题7：定时器不工作

**症状**：定时器创建了但不执行

**解决方法**：
```csharp
// 检查1：是否启动了定时器
int timerId = TimerMgr.Instance.CreateTimer(...);
TimerMgr.Instance.StartTimer(timerId);  // 必须启动

// 检查2：isRealTime参数
// false=受timeScale影响，游戏暂停时定时器也会暂停
// true=不受影响

// 检查3：定时器是否被移除
TimerMgr.Instance.RemoveTimer(timerId);  // 移除后就不执行了

// 检查4：回调是否为null
int timerId = TimerMgr.Instance.CreateTimer(
    isRealTime: false,
    allTime: 5000,
    overCallBack: null,  // 这里不能是null！
    intervalTime: 1000,
    callBack: null       // 这里可以是null
);
```

---

## 我的第一个游戏完整示例

下面是一个完整的游戏示例，整合了框架的所有主要功能。你可以直接复制这些代码到你的项目中。

### 项目结构

```
Assets/
├── Scripts/
│   └── Framework/          (框架核心代码)
├── Resources/
│   ├── Prefabs/
│   │   ├── Player.prefab
│   │   ├── Enemy.prefab
│   │   └── Bullet.prefab
│   ├── Audio/
│   │   ├── BGM.mp3
│   │   └── Fire.wav
│   └── Images/
│       └── Background.png
└── Scenes/
    └── MainGame.unity
```

### 代码实现

```csharp
// ==================== 游戏管理器 ====================
using UnityEngine;

public class GameManager : SingletonAutoMono<GameManager>
{
    public int score = 0;
    public int level = 1;
    public bool isPaused = false;
    
    private void Start()
    {
        // 初始化
        MusicMgr.Instance.PlayBKMusic("BGM");
        
        // 注册事件
        EventCenter.Instance.AddEventListener<int>(E_GameEvent.E_Score_Add, OnScoreAdd);
        EventCenter.Instance.AddEventListener(E_GameEvent.E_Game_Over, OnGameOver);
    }
    
    private void OnScoreAdd(int value)
    {
        score += value;
        Debug.Log($"得分：{score}");
        
        // 升级
        if (score >= level * 500)
        {
            level++;
            Debug.Log($"升级！当前等级：{level}");
        }
    }
    
    private void OnGameOver()
    {
        isPaused = true;
        Time.timeScale = 0;
        
        UIMgr.Instance.ShowPanel<GameOverPanel>(E_UILayer.Top, (panel) =>
        {
            panel.ShowResult(score, level);
        });
    }
    
    public void TogglePause()
    {
        isPaused = !isPaused;
        Time.timeScale = isPaused ? 0 : 1;
        MusicMgr.Instance.PlayOrPauseSound(!isPaused);
        
        if (isPaused)
        {
            UIMgr.Instance.ShowPanel<PausePanel>(E_UILayer.System);
        }
    }
}

// ==================== 事件类型 ====================
public enum E_GameEvent
{
    E_Score_Add,
    E_Game_Over,
    E_Player_Dead,
    E_Player_Hit,
    E_Enemy_Killed,
}

// ==================== 玩家控制器 ====================
public class PlayerController : MonoBehaviour
{
    public float speed = 10f;
    public int hp = 100;
    
    private void Update()
    {
        if (GameManager.Instance.isPaused) return;
        
        // 移动
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");
        Vector3 move = new Vector3(h, 0, v) * speed * Time.deltaTime;
        transform.Translate(move);
        
        // 跳跃
        if (Input.GetKeyDown(KeyCode.Space))
        {
            Jump();
        }
        
        // 射击
        if (Input.GetMouseButtonDown(0))
        {
            Fire();
        }
        
        // 暂停
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            GameManager.Instance.TogglePause();
        }
    }
    
    private void Jump()
    {
        GetComponent<Rigidbody>().AddForce(Vector3.up * 500f);
        MusicMgr.Instance.PlaySound("jump");
    }
    
    private void Fire()
    {
        Bullet bullet = PoolMgr.Instance.GetObj<Bullet>("Bullet");
        bullet.transform.position = transform.position + Vector3.forward;
        bullet.Fire(Vector3.forward);
        MusicMgr.Instance.PlaySound("fire");
    }
    
    public void TakeDamage(int damage)
    {
        hp -= damage;
        if (hp <= 0)
        {
            hp = 0;
            EventCenter.Instance.EventTrigger(E_GameEvent.E_Player_Dead);
        }
    }
}

// ==================== 子弹 ====================
public class Bullet : MonoBehaviour, IPoolObject
{
    public float speed = 20f;
    private Rigidbody rb;
    
    private void Awake()
    {
        rb = GetComponent<Rigidbody>();
    }
    
    public void Fire(Vector3 direction)
    {
        rb.velocity = direction * speed;
    }
    
    public void ResetInfo()
    {
        rb.velocity = Vector3.zero;
        gameObject.SetActive(false);
    }
}

// ==================== 敌人 ====================
public class Enemy : MonoBehaviour, IPoolObject
{
    public int hp = 50;
    public int damage = 10;
    public int scoreValue = 100;
    
    public void Init(int level)
    {
        hp = 50 + level * 10;
        damage = 10 + level * 2;
        gameObject.SetActive(true);
    }
    
    public void TakeDamage(int damage)
    {
        hp -= damage;
        if (hp <= 0)
        {
            Die();
        }
    }
    
    private void Die()
    {
        EventCenter.Instance.EventTrigger<int>(E_GameEvent.E_Enemy_Killed, scoreValue);
        PoolMgr.Instance.PushObj(this);
    }
    
    public void ResetInfo()
    {
        hp = 0;
        gameObject.SetActive(false);
    }
}

// ==================== 敌人生成器 ====================
public class EnemySpawner : MonoBehaviour
{
    public float spawnInterval = 2f;
    private float timer = 0;
    
    private void Update()
    {
        if (GameManager.Instance.isPaused) return;
        
        timer += Time.deltaTime;
        if (timer >= spawnInterval)
        {
            timer = 0;
            SpawnEnemy();
        }
    }
    
    private void SpawnEnemy()
    {
        Enemy enemy = PoolMgr.Instance.GetObj<Enemy>("Enemy");
        enemy.transform.position = new Vector3(Random.Range(-8f, 8f), 1f, 8f);
        enemy.Init(GameManager.Instance.level);
    }
}

// ==================== 碰撞检测 ====================
public class CollisionHandler : MonoBehaviour
{
    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Enemy"))
        {
            PlayerController player = GetComponent<PlayerController>();
            Enemy enemy = other.GetComponent<Enemy>();
            
            if (player != null && enemy != null)
            {
                player.TakeDamage(enemy.damage);
                PoolMgr.Instance.PushObj(enemy);
            }
        }
    }
}

// ==================== 玩家死亡处理 ====================
public class PlayerDeathHandler : MonoBehaviour
{
    private void OnEnable()
    {
        EventCenter.Instance.AddEventListener(E_GameEvent.E_Player_Dead, OnPlayerDead);
    }
    
    private void OnDisable()
    {
        EventCenter.Instance.RemoveEventListener(E_GameEvent.E_Player_Dead, OnPlayerDead);
    }
    
    private void OnPlayerDead()
    {
        EventCenter.Instance.EventTrigger(E_GameEvent.E_Game_Over);
    }
}

// ==================== 主面板 ====================
public class MainPanel : BasePanel
{
    public Text scoreText;
    public Text levelText;
    public Slider hpSlider;
    
    protected override void Awake()
    {
        base.Awake();
        
        scoreText = GetControl<Text>("ScoreText");
        levelText = GetControl<Text>("LevelText");
        hpSlider = GetControl<Slider>("HpSlider");
    }
    
    public override void ShowMe()
    {
        gameObject.SetActive(true);
    }
    
    public override void HideMe()
    {
        gameObject.SetActive(false);
    }
    
    private void Update()
    {
        PlayerController player = FindObjectOfType<PlayerController>();
        if (player != null)
        {
            hpSlider.value = (float)player.hp / 100f;
        }
    }
}

// ==================== 游戏结束面板 ====================
public class GameOverPanel : BasePanel
{
    public Text finalScoreText;
    public Text finalLevelText;
    public Button restartButton;
    
    protected override void Awake()
    {
        base.Awake();
        
        finalScoreText = GetControl<Text>("FinalScoreText");
        finalLevelText = GetControl<Text>("FinalLevelText");
        restartButton = GetControl<Button>("RestartButton");
        
        restartButton.onClick.AddListener(OnRestart);
    }
    
    public void ShowResult(int score, int level)
    {
        finalScoreText.text = $"最终得分：{score}";
        finalLevelText.text = $"最高等级：{level}";
    }
    
    public override void ShowMe()
    {
        gameObject.SetActive(true);
    }
    
    public override void HideMe()
    {
        gameObject.SetActive(false);
    }
    
    private void OnRestart()
    {
        UnityEngine.SceneManagement.SceneManager.LoadScene(
            UnityEngine.SceneManagement.SceneManager.GetActiveScene().name);
    }
}

// ==================== 暂停面板 ====================
public class PausePanel : BasePanel
{
    public Button resumeButton;
    public Button quitButton;
    
    protected override void Awake()
    {
        base.Awake();
        
        resumeButton = GetControl<Button>("ResumeButton");
        quitButton = GetControl<Button>("QuitButton");
        
        resumeButton.onClick.AddListener(OnResume);
        quitButton.onClick.AddListener(OnQuit);
    }
    
    public override void ShowMe()
    {
        gameObject.SetActive(true);
    }
    
    public override void HideMe()
    {
        gameObject.SetActive(false);
    }
    
    private void OnResume()
    {
        GameManager.Instance.TogglePause();
        HideMe();
    }
    
    private void OnQuit()
    {
        Application.Quit();
    }
}

// ==================== 游戏启动器 ====================
public class GameLauncher : MonoBehaviour
{
    private void Awake()
    {
        // 预热对象池
        for (int i = 0; i < 10; i++)
        {
            var bullet = PoolMgr.Instance.GetObj<Bullet>("Bullet");
            PoolMgr.Instance.PushObj(bullet);
            
            var enemy = PoolMgr.Instance.GetObj<Enemy>("Enemy");
            PoolMgr.Instance.PushObj(enemy);
        }
        
        Debug.Log("游戏启动！");
    }
}
```

### 场景设置步骤

1. 创建场景，命名为"MainGame"
2. 创建空物体，命名为"GameStart"，挂载"GameLauncher"脚本
3. 创建Player：
   - 创建胶囊体，添加Rigidbody
   - 挂载"PlayerController"脚本
   - 挂载"CollisionHandler"脚本
   - 挂载"PlayerDeathHandler"脚本
   - 设置Tag为"Player"
4. 创建EnemySpawner空物体，挂载"EnemySpawner"脚本
5. 创建UI：
   - Canvas下创建Panel，挂载"MainPanel"脚本
   - 创建GameOverPanel，预制体化
   - 创建PausePanel，预制体化
6. 预制体：
   - Bullet：挂载Bullet脚本和PoolObj脚本
   - Enemy：挂载Enemy脚本和PoolObj脚本

### 运行游戏

按下Unity的播放按钮，你的第一个游戏就运行起来了！

- **移动**：WASD
- **跳跃**：空格
- **射击**：鼠标左键
- **暂停**：ESC

---

## 结语

恭喜你完成了新手入门教程！

这个框架还有很多功能等待你去探索。建议你：

1. **多实践**：复制示例代码，运行看看效果
2. **多尝试**：修改参数，看看会发生什么
3. **多看文档**：遇到问题先查文档
4. **看源码**：框架源码是最好的学习资料

祝你开发愉快！